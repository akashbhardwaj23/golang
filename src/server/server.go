package server

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"
)

type GeneratedReportRequest struct {
	UserId string
}

type GeneratedReportResponse struct {
	ReportId string
	Error    string
}

type HealthCheckRequest struct{}

type HealthCheckResponse struct {
	Status string
}

type ReportServiceServer interface {
	GenerateReport(context.Context, *GeneratedReportRequest) (*GeneratedReportResponse, error)
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
}

// RegisterReportServiceServer would be generated by protoc
func RegisterReportServiceServer(s interface{}, srv ReportServiceServer) {
	// This would be generated by protoc-gen-go-grpc
	log.Println("Service registered")
}

type ReportServer struct {
	reports map[string]string
	mutx    sync.RWMutex
}

func NewReportServer() *ReportServer {
	return &ReportServer{
		reports: make(map[string]string),
	}
}

func (s *ReportServer) GenerateReport(ctx context.Context, req *GeneratedReportRequest) (*GeneratedReportResponse, error) {
	log.Printf("[%s] GenerateReport called for user: %s", time.Now().Format(time.RFC3339), req.UserId)

	if req.UserId == "" {
		log.Panicf("[%s] Error: Empty User Id", time.Now().Format(time.RFC3339))
		return &GeneratedReportResponse{
			ReportId: "",
			Error:    "user_id cannot be empty",
		}, nil
	}

	reportId := fmt.Sprintf("report_%s_%d", req.UserId, time.Now().Unix())

	// Simulate the report generation
	time.Sleep(100 * time.Millisecond)

	s.mutx.Lock()
	s.reports[reportId] = fmt.Sprintf("Report content for user %s generated at %s",
		req.UserId, time.Now().Format(time.RFC3339))
	s.mutx.Unlock()

	log.Printf("[%s] Report generated successfully: %s", time.Now().Format(time.RFC3339), reportId)

	return &GeneratedReportResponse{
		ReportId: reportId,
		Error:    "",
	}, nil

}

func (s *ReportServer) HealthCheck(ctx context.Context, req *HealthCheckRequest) (*HealthCheckResponse, error) {
	log.Printf("[%s] HealthCheck called", time.Now().Format(time.RFC3339))

	s.mutx.RLock()
	reportCount := len(s.reports)
	s.mutx.RUnlock()

	status := fmt.Sprintf("healthy - %d reports in memory", reportCount)

	return &HealthCheckResponse{
		Status: status,
	}, nil
}

func (s *ReportServer) GetReportCount() int {
	s.mutx.RLock()
	defer s.mutx.RUnlock()
	return len(s.reports)
}

func (s *ReportServer) GetAllReports() map[string]string {
	s.mutx.RLock()
	defer s.mutx.RUnlock()

	reports := make(map[string]string)

	for k, v := range s.reports {
		reports[k] = v
	}

	return reports
}
